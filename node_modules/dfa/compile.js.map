{"version":3,"file":"compile.js","sources":["src/utils.js","src/nodes.js","src/grammar.js","src/SymbolTable.js","src/dfa.js","src/StateMachine.js","src/compile.js"],"sourcesContent":["/**\n * Returns a new set representing the union of a and b.\n */\nexport function union(a, b) {\n  let s = new Set(a);\n  addAll(s, b);\n  return s;\n}\n\n/**\n * Adds all items from the set b to a.\n */\nexport function addAll(a, b) {\n  for (let x of b) {\n    a.add(x);\n  }\n}\n\n/**\n * Returns whether two sets are equal\n */\nexport function equal(a, b) {\n  if (a === b)\n    return true;\n\n  if (a.size !== b.size)\n    return false;\n\n  for (let x of a) {\n    if (!b.has(x)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n","import {addAll, union} from './utils';\n\n/**\n * Base AST node\n */\nexport class Node {\n  constructor() {\n    Object.defineProperty(this, 'followpos', {value: new Set})\n  }\n\n  calcFollowpos() {\n    for (let key in this) {\n      if (this[key] instanceof Node) {\n        this[key].calcFollowpos();\n      }\n    }\n  }\n}\n\n/**\n * Represents a variable reference\n */\nexport class Variable extends Node {\n  constructor(name) {\n    super();\n    this.name = name;\n  }\n\n  copy() {\n    return new Variable(this.name);\n  }\n}\n\n/**\n * Represents a comment\n */\nexport class Comment extends Node {\n  constructor(value) {\n    super();\n    this.value = value;\n  }\n}\n\n/**\n * Represents an assignment statement.\n * e.g. `variable = expression;`\n */\nexport class Assignment extends Node {\n  constructor(variable, expression) {\n    super();\n    this.variable = variable;\n    this.expression = expression;\n  }\n}\n\n/**\n * Represents an alternation.\n * e.g. `a | b`\n */\nexport class Alternation extends Node {\n  constructor(a, b) {\n    super();\n    this.a = a;\n    this.b = b;\n  }\n\n  get nullable() {\n    return this.a.nullable || this.b.nullable;\n  }\n\n  get firstpos() {\n    return union(this.a.firstpos, this.b.firstpos);\n  }\n\n  get lastpos() {\n    return union(this.a.lastpos, this.b.lastpos);\n  }\n\n  copy() {\n    return new Alternation(this.a.copy(), this.b.copy());\n  }\n}\n\n/**\n * Represents a concatenation, or chain.\n * e.g. `a b c`\n */\nexport class Concatenation extends Node {\n  constructor(a, b) {\n    super();\n    this.a = a;\n    this.b = b;\n  }\n\n  get nullable() {\n    return this.a.nullable && this.b.nullable;\n  }\n\n  get firstpos() {\n    let s = this.a.firstpos;\n    if (this.a.nullable) {\n      s = union(s, this.b.firstpos);\n    }\n\n    return s;\n  }\n\n  get lastpos() {\n    let s = this.b.lastpos;\n    if (this.b.nullable) {\n      s = union(s, this.a.lastpos);\n    }\n\n    return s;\n  }\n\n  calcFollowpos() {\n    super.calcFollowpos();\n    for (let n of this.a.lastpos) {\n      addAll(n.followpos, this.b.firstpos);\n    }\n  }\n\n  copy() {\n    return new Concatenation(this.a.copy(), this.b.copy());\n  }\n}\n\n/**\n * Represents a repetition.\n * e.g. `a+`, `b*`, or `c?`\n */\nexport class Repeat extends Node {\n  constructor(expression, op) {\n    super();\n    this.expression = expression;\n    this.op = op;\n  }\n\n  get nullable() {\n    return this.op === '*' || this.op === '?';\n  }\n\n  get firstpos() {\n    return this.expression.firstpos;\n  }\n\n  get lastpos() {\n    return this.expression.lastpos;\n  }\n\n  calcFollowpos() {\n    super.calcFollowpos();\n    if (this.op === '*' || this.op === '+') {\n      for (let n of this.lastpos) {\n        addAll(n.followpos, this.firstpos);\n      }\n    }\n  }\n\n  copy() {\n    return new Repeat(this.expression.copy(), this.op);\n  }\n}\n\nexport function buildRepetition(expression, min = 0, max = Infinity) {\n  if (min < 0 || min > max) {\n    throw new Error(`Invalid repetition range: ${min} ${max}`);\n  }\n\n  let res = null;\n  for (let i = 0; i < min; i++) {\n    res = concat(res, expression.copy());\n  }\n\n  if (max === Infinity) {\n    res = concat(res, new Repeat(expression.copy(), '*'));\n  } else {\n    for (let i = min; i < max; i++) {\n      res = concat(res, new Repeat(expression.copy(), '?'))\n    }\n  }\n\n  return res;\n}\n\nfunction concat(a, b) {\n  if (!a) {\n    return b;\n  }\n\n  return new Concatenation(a, b);\n}\n\n/**\n * Base class for leaf nodes\n */\nclass Leaf extends Node {\n  get nullable() {\n    return false;\n  }\n\n  get firstpos() {\n    return new Set([this]);\n  }\n\n  get lastpos() {\n    return new Set([this]);\n  }\n}\n\n/**\n * Represents a literal value, e.g. a number\n */\nexport class Literal extends Leaf {\n  constructor(value) {\n    super();\n    this.value = value;\n  }\n\n  copy() {\n    return new Literal(this.value);\n  }\n}\n\n/**\n * Marks the end of an expression\n */\nexport class EndMarker extends Leaf {}\n\n/**\n * Represents a tag\n * e.g. `a:(a b)`\n */\nexport class Tag extends Leaf {\n  constructor(name) {\n    super();\n    this.name = name;\n  }\n\n  get nullable() {\n    return true;\n  }\n\n  copy() {\n    return new Tag(this.name);\n  }\n}\n","/*\n * Generated by PEG.js 0.10.0.\n *\n * http://pegjs.org/\n */\n\n\"use stri